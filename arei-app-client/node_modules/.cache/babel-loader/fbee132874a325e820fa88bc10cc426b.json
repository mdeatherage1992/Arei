{"ast":null,"code":"// Â© 2013 - 2016 Rob Wu <rob@robwu.nl>\n// Released under the MIT license\n'use strict';\n\nvar httpProxy = require('http-proxy');\n\nvar net = require('net');\n\nvar url = require('url');\n\nvar regexp_tld = require('./regexp-top-level-domain');\n\nvar getProxyForUrl = require('proxy-from-env').getProxyForUrl;\n\nvar help_text = {};\n\nfunction showUsage(help_file, headers, response) {\n  var isHtml = /\\.html$/.test(help_file);\n  headers['content-type'] = isHtml ? 'text/html' : 'text/plain';\n\n  if (help_text[help_file] != null) {\n    response.writeHead(200, headers);\n    response.end(help_text[help_file]);\n  } else {\n    require('fs').readFile(help_file, 'utf8', function (err, data) {\n      if (err) {\n        console.error(err);\n        response.writeHead(500, headers);\n        response.end();\n      } else {\n        help_text[help_file] = data;\n        showUsage(help_file, headers, response); // Recursive call, but since data is a string, the recursion will end\n      }\n    });\n  }\n}\n/**\n * Check whether the specified hostname is valid.\n *\n * @param hostname {string} Host name (excluding port) of requested resource.\n * @return {boolean} Whether the requested resource can be accessed.\n */\n\n\nfunction isValidHostName(hostname) {\n  return !!(regexp_tld.test(hostname) || net.isIPv4(hostname) || net.isIPv6(hostname));\n}\n/**\n * Adds CORS headers to the response headers.\n *\n * @param headers {object} Response headers\n * @param request {ServerRequest}\n */\n\n\nfunction withCORS(headers, request) {\n  headers['access-control-allow-origin'] = '*';\n  var corsMaxAge = request.corsAnywhereRequestState.corsMaxAge;\n\n  if (corsMaxAge) {\n    headers['access-control-max-age'] = corsMaxAge;\n  }\n\n  if (request.headers['access-control-request-method']) {\n    headers['access-control-allow-methods'] = request.headers['access-control-request-method'];\n    delete request.headers['access-control-request-method'];\n  }\n\n  if (request.headers['access-control-request-headers']) {\n    headers['access-control-allow-headers'] = request.headers['access-control-request-headers'];\n    delete request.headers['access-control-request-headers'];\n  }\n\n  headers['access-control-expose-headers'] = Object.keys(headers).join(',');\n  return headers;\n}\n/**\n * Performs the actual proxy request.\n *\n * @param req {ServerRequest} Incoming http request\n * @param res {ServerResponse} Outgoing (proxied) http request\n * @param proxy {HttpProxy}\n */\n\n\nfunction proxyRequest(req, res, proxy) {\n  var location = req.corsAnywhereRequestState.location;\n  req.url = location.path;\n  var proxyOptions = {\n    changeOrigin: false,\n    prependPath: false,\n    target: location,\n    headers: {\n      host: location.host\n    },\n    // HACK: Get hold of the proxyReq object, because we need it later.\n    // https://github.com/nodejitsu/node-http-proxy/blob/v1.11.1/lib/http-proxy/passes/web-incoming.js#L144\n    buffer: {\n      pipe: function pipe(proxyReq) {\n        var proxyReqOn = proxyReq.on; // Intercepts the handler that connects proxyRes to res.\n        // https://github.com/nodejitsu/node-http-proxy/blob/v1.11.1/lib/http-proxy/passes/web-incoming.js#L146-L158\n\n        proxyReq.on = function (eventName, listener) {\n          if (eventName !== 'response') {\n            return proxyReqOn.call(this, eventName, listener);\n          }\n\n          return proxyReqOn.call(this, 'response', function (proxyRes) {\n            if (onProxyResponse(proxy, proxyReq, proxyRes, req, res)) {\n              try {\n                listener(proxyRes);\n              } catch (err) {\n                // Wrap in try-catch because an error could occur:\n                // \"RangeError: Invalid status code: 0\"\n                // https://github.com/Rob--W/cors-anywhere/issues/95\n                // https://github.com/nodejitsu/node-http-proxy/issues/1080\n                // Forward error (will ultimately emit the 'error' event on our proxy object):\n                // https://github.com/nodejitsu/node-http-proxy/blob/v1.11.1/lib/http-proxy/passes/web-incoming.js#L134\n                proxyReq.emit('error', err);\n              }\n            }\n          });\n        };\n\n        return req.pipe(proxyReq);\n      }\n    }\n  };\n  var proxyThroughUrl = req.corsAnywhereRequestState.getProxyForUrl(location.href);\n\n  if (proxyThroughUrl) {\n    proxyOptions.target = proxyThroughUrl;\n    proxyOptions.toProxy = true; // If a proxy URL was set, req.url must be an absolute URL. Then the request will not be sent\n    // directly to the proxied URL, but through another proxy.\n\n    req.url = location.href;\n  } // Start proxying the request\n\n\n  proxy.web(req, res, proxyOptions);\n}\n/**\n * This method modifies the response headers of the proxied response.\n * If a redirect is detected, the response is not sent to the client,\n * and a new request is initiated.\n *\n * client (req) -> CORS Anywhere -> (proxyReq) -> other server\n * client (res) <- CORS Anywhere <- (proxyRes) <- other server\n *\n * @param proxy {HttpProxy}\n * @param proxyReq {ClientRequest} The outgoing request to the other server.\n * @param proxyRes {ServerResponse} The response from the other server.\n * @param req {IncomingMessage} Incoming HTTP request, augmented with property corsAnywhereRequestState\n * @param req.corsAnywhereRequestState {object}\n * @param req.corsAnywhereRequestState.location {object} See parseURL\n * @param req.corsAnywhereRequestState.getProxyForUrl {function} See proxyRequest\n * @param req.corsAnywhereRequestState.proxyBaseUrl {string} Base URL of the CORS API endpoint\n * @param req.corsAnywhereRequestState.maxRedirects {number} Maximum number of redirects\n * @param req.corsAnywhereRequestState.redirectCount_ {number} Internally used to count redirects\n * @param res {ServerResponse} Outgoing response to the client that wanted to proxy the HTTP request.\n *\n * @returns {boolean} true if http-proxy should continue to pipe proxyRes to res.\n */\n\n\nfunction onProxyResponse(proxy, proxyReq, proxyRes, req, res) {\n  var requestState = req.corsAnywhereRequestState;\n  var statusCode = proxyRes.statusCode;\n\n  if (!requestState.redirectCount_) {\n    res.setHeader('x-request-url', requestState.location.href);\n  } // Handle redirects\n\n\n  if (statusCode === 301 || statusCode === 302 || statusCode === 303 || statusCode === 307 || statusCode === 308) {\n    var locationHeader = proxyRes.headers.location;\n\n    if (locationHeader) {\n      locationHeader = url.resolve(requestState.location.href, locationHeader);\n\n      if (statusCode === 301 || statusCode === 302 || statusCode === 303) {\n        // Exclude 307 & 308, because they are rare, and require preserving the method + request body\n        requestState.redirectCount_ = requestState.redirectCount_ + 1 || 1;\n\n        if (requestState.redirectCount_ <= requestState.maxRedirects) {\n          // Handle redirects within the server, because some clients (e.g. Android Stock Browser)\n          // cancel redirects.\n          // Set header for debugging purposes. Do not try to parse it!\n          res.setHeader('X-CORS-Redirect-' + requestState.redirectCount_, statusCode + ' ' + locationHeader);\n          req.method = 'GET';\n          req.headers['content-length'] = '0';\n          delete req.headers['content-type'];\n          requestState.location = parseURL(locationHeader); // Remove all listeners (=reset events to initial state)\n\n          req.removeAllListeners(); // Remove the error listener so that the ECONNRESET \"error\" that\n          // may occur after aborting a request does not propagate to res.\n          // https://github.com/nodejitsu/node-http-proxy/blob/v1.11.1/lib/http-proxy/passes/web-incoming.js#L134\n\n          proxyReq.removeAllListeners('error');\n          proxyReq.once('error', function catchAndIgnoreError() {});\n          proxyReq.abort(); // Initiate a new proxy request.\n\n          proxyRequest(req, res, proxy);\n          return false;\n        }\n      }\n\n      proxyRes.headers.location = requestState.proxyBaseUrl + '/' + locationHeader;\n    }\n  } // Strip cookies\n\n\n  delete proxyRes.headers['set-cookie'];\n  delete proxyRes.headers['set-cookie2'];\n  proxyRes.headers['x-final-url'] = requestState.location.href;\n  withCORS(proxyRes.headers, req);\n  return true;\n}\n/**\n * @param req_url {string} The requested URL (scheme is optional).\n * @return {object} URL parsed using url.parse\n */\n\n\nfunction parseURL(req_url) {\n  var match = req_url.match(/^(?:(https?:)?\\/\\/)?(([^\\/?]+?)(?::(\\d{0,5})(?=[\\/?]|$))?)([\\/?][\\S\\s]*|$)/i); //                              ^^^^^^^          ^^^^^^^^      ^^^^^^^                ^^^^^^^^^^^^\n  //                            1:protocol       3:hostname     4:port                 5:path + query string\n  //                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  //                                            2:host\n\n  if (!match) {\n    return null;\n  }\n\n  if (!match[1]) {\n    // Scheme is omitted.\n    if (req_url.lastIndexOf('//', 0) === -1) {\n      // \"//\" is omitted.\n      req_url = '//' + req_url;\n    }\n\n    req_url = (match[4] === '443' ? 'https:' : 'http:') + req_url;\n  }\n\n  return url.parse(req_url);\n} // Request handler factory\n\n\nfunction getHandler(options, proxy) {\n  var corsAnywhere = {\n    getProxyForUrl: getProxyForUrl,\n    // Function that specifies the proxy to use\n    maxRedirects: 5,\n    // Maximum number of redirects to be followed.\n    originBlacklist: [],\n    // Requests from these origins will be blocked.\n    originWhitelist: [],\n    // If non-empty, requests not from an origin in this list will be blocked.\n    checkRateLimit: null,\n    // Function that may enforce a rate-limit by returning a non-empty string.\n    redirectSameOrigin: false,\n    // Redirect the client to the requested URL for same-origin requests.\n    requireHeader: null,\n    // Require a header to be set?\n    removeHeaders: [],\n    // Strip these request headers.\n    setHeaders: {},\n    // Set these request headers.\n    corsMaxAge: 0,\n    // If set, an Access-Control-Max-Age header with this value (in seconds) will be added.\n    helpFile: __dirname + '/help.txt'\n  };\n  Object.keys(corsAnywhere).forEach(function (option) {\n    if (Object.prototype.hasOwnProperty.call(options, option)) {\n      corsAnywhere[option] = options[option];\n    }\n  }); // Convert corsAnywhere.requireHeader to an array of lowercase header names, or null.\n\n  if (corsAnywhere.requireHeader) {\n    if (typeof corsAnywhere.requireHeader === 'string') {\n      corsAnywhere.requireHeader = [corsAnywhere.requireHeader.toLowerCase()];\n    } else if (!Array.isArray(corsAnywhere.requireHeader) || corsAnywhere.requireHeader.length === 0) {\n      corsAnywhere.requireHeader = null;\n    } else {\n      corsAnywhere.requireHeader = corsAnywhere.requireHeader.map(function (headerName) {\n        return headerName.toLowerCase();\n      });\n    }\n  }\n\n  var hasRequiredHeaders = function hasRequiredHeaders(headers) {\n    return !corsAnywhere.requireHeader || corsAnywhere.requireHeader.some(function (headerName) {\n      return Object.hasOwnProperty.call(headers, headerName);\n    });\n  };\n\n  return function (req, res) {\n    req.corsAnywhereRequestState = {\n      getProxyForUrl: corsAnywhere.getProxyForUrl,\n      maxRedirects: corsAnywhere.maxRedirects,\n      corsMaxAge: corsAnywhere.corsMaxAge\n    };\n    var cors_headers = withCORS({}, req);\n\n    if (req.method === 'OPTIONS') {\n      // Pre-flight request. Reply successfully:\n      res.writeHead(200, cors_headers);\n      res.end();\n      return;\n    }\n\n    var location = parseURL(req.url.slice(1));\n\n    if (!location) {\n      // Invalid API call. Show how to correctly use the API\n      showUsage(corsAnywhere.helpFile, cors_headers, res);\n      return;\n    }\n\n    if (location.host === 'iscorsneeded') {\n      // Is CORS needed? This path is provided so that API consumers can test whether it's necessary\n      // to use CORS. The server's reply is always No, because if they can read it, then CORS headers\n      // are not necessary.\n      res.writeHead(200, {\n        'Content-Type': 'text/plain'\n      });\n      res.end('no');\n      return;\n    }\n\n    if (location.port > 65535) {\n      // Port is higher than 65535\n      res.writeHead(400, 'Invalid port', cors_headers);\n      res.end('Port number too large: ' + location.port);\n      return;\n    }\n\n    if (!/^\\/https?:/.test(req.url) && !isValidHostName(location.hostname)) {\n      // Don't even try to proxy invalid hosts (such as /favicon.ico, /robots.txt)\n      res.writeHead(404, 'Invalid host', cors_headers);\n      res.end('Invalid host: ' + location.hostname);\n      return;\n    }\n\n    if (!hasRequiredHeaders(req.headers)) {\n      res.writeHead(400, 'Header required', cors_headers);\n      res.end('Missing required request header. Must specify one of: ' + corsAnywhere.requireHeader);\n      return;\n    }\n\n    var origin = req.headers.origin || '';\n\n    if (corsAnywhere.originBlacklist.indexOf(origin) >= 0) {\n      res.writeHead(403, 'Forbidden', cors_headers);\n      res.end('The origin \"' + origin + '\" was blacklisted by the operator of this proxy.');\n      return;\n    }\n\n    if (corsAnywhere.originWhitelist.length && corsAnywhere.originWhitelist.indexOf(origin) === -1) {\n      res.writeHead(403, 'Forbidden', cors_headers);\n      res.end('The origin \"' + origin + '\" was not whitelisted by the operator of this proxy.');\n      return;\n    }\n\n    var rateLimitMessage = corsAnywhere.checkRateLimit && corsAnywhere.checkRateLimit(origin);\n\n    if (rateLimitMessage) {\n      res.writeHead(429, 'Too Many Requests', cors_headers);\n      res.end('The origin \"' + origin + '\" has sent too many requests.\\n' + rateLimitMessage);\n      return;\n    }\n\n    if (corsAnywhere.redirectSameOrigin && origin && location.href[origin.length] === '/' && location.href.lastIndexOf(origin, 0) === 0) {\n      // Send a permanent redirect to offload the server. Badly coded clients should not waste our resources.\n      cors_headers.vary = 'origin';\n      cors_headers['cache-control'] = 'private';\n      cors_headers.location = location.href;\n      res.writeHead(301, 'Please use a direct request', cors_headers);\n      res.end();\n      return;\n    }\n\n    var isRequestedOverHttps = req.connection.encrypted || /^\\s*https/.test(req.headers['x-forwarded-proto']);\n    var proxyBaseUrl = (isRequestedOverHttps ? 'https://' : 'http://') + req.headers.host;\n    corsAnywhere.removeHeaders.forEach(function (header) {\n      delete req.headers[header];\n    });\n    Object.keys(corsAnywhere.setHeaders).forEach(function (header) {\n      req.headers[header] = corsAnywhere.setHeaders[header];\n    });\n    req.corsAnywhereRequestState.location = location;\n    req.corsAnywhereRequestState.proxyBaseUrl = proxyBaseUrl;\n    proxyRequest(req, res, proxy);\n  };\n} // Create server with default and given values\n// Creator still needs to call .listen()\n\n\nexports.createServer = function createServer(options) {\n  options = options || {}; // Default options:\n\n  var httpProxyOptions = {\n    xfwd: true // Append X-Forwarded-* headers\n\n  }; // Allow user to override defaults and add own options\n\n  if (options.httpProxyOptions) {\n    Object.keys(options.httpProxyOptions).forEach(function (option) {\n      httpProxyOptions[option] = options.httpProxyOptions[option];\n    });\n  }\n\n  var proxy = httpProxy.createServer(httpProxyOptions);\n  var requestHandler = getHandler(options, proxy);\n  var server;\n\n  if (options.httpsOptions) {\n    server = require('https').createServer(options.httpsOptions, requestHandler);\n  } else {\n    server = require('http').createServer(requestHandler);\n  } // When the server fails, just show a 404 instead of Internal server error\n\n\n  proxy.on('error', function (err, req, res) {\n    if (res.headersSent) {\n      // This could happen when a protocol error occurs when an error occurs\n      // after the headers have been received (and forwarded). Do not write\n      // the headers because it would generate an error.\n      return;\n    } // When the error occurs after setting headers but before writing the response,\n    // then any previously set headers must be removed.\n\n\n    var headerNames = res.getHeaderNames ? res.getHeaderNames() : Object.keys(res._headers || {});\n    headerNames.forEach(function (name) {\n      res.removeHeader(name);\n    });\n    res.writeHead(404, {\n      'Access-Control-Allow-Origin': '*'\n    });\n    res.end('Not found because of proxy error: ' + err);\n  });\n  return server;\n};","map":null,"metadata":{},"sourceType":"script"}