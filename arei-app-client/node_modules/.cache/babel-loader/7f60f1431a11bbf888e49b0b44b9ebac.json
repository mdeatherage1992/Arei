{"ast":null,"code":"var http = require('http'),\n    https = require('https'),\n    web_o = require('./web-outgoing'),\n    common = require('../common'),\n    passes = exports;\n\nweb_o = Object.keys(web_o).map(function (pass) {\n  return web_o[pass];\n});\n/*!\n * Array of passes.\n *\n * A `pass` is just a function that is executed on `req, res, options`\n * so that you can easily add new checks while still keeping the base\n * flexible.\n */\n\n[// <--\n\n/**\n * Sets `content-length` to '0' if request is of DELETE type.\n *\n * @param {ClientRequest} Req Request object\n * @param {IncomingMessage} Res Response object\n * @param {Object} Options Config object passed to the proxy\n *\n * @api private\n */\nfunction deleteLength(req, res, options) {\n  if ((req.method === 'DELETE' || req.method === 'OPTIONS') && !req.headers['content-length']) {\n    req.headers['content-length'] = '0';\n  }\n},\n/**\n * Sets timeout in request socket if it was specified in options.\n *\n * @param {ClientRequest} Req Request object\n * @param {IncomingMessage} Res Response object\n * @param {Object} Options Config object passed to the proxy\n *\n * @api private\n */\nfunction timeout(req, res, options) {\n  if (options.timeout) {\n    req.socket.setTimeout(options.timeout);\n  }\n},\n/**\n * Sets `x-forwarded-*` headers if specified in config.\n *\n * @param {ClientRequest} Req Request object\n * @param {IncomingMessage} Res Response object\n * @param {Object} Options Config object passed to the proxy\n *\n * @api private\n */\nfunction XHeaders(req, res, options) {\n  if (!options.xfwd) return;\n  var encrypted = req.isSpdy || common.hasEncryptedConnection(req);\n  var values = {\n    for: req.connection.remoteAddress || req.socket.remoteAddress,\n    port: common.getPort(req),\n    proto: encrypted ? 'https' : 'http'\n  };\n  ['for', 'port', 'proto'].forEach(function (header) {\n    req.headers['x-forwarded-' + header] = (req.headers['x-forwarded-' + header] || '') + (req.headers['x-forwarded-' + header] ? ',' : '') + values[header];\n  });\n},\n/**\n * Does the actual proxying. If `forward` is enabled fires up\n * a ForwardStream, same happens for ProxyStream. The request\n * just dies otherwise.\n *\n * @param {ClientRequest} Req Request object\n * @param {IncomingMessage} Res Response object\n * @param {Object} Options Config object passed to the proxy\n *\n * @api private\n */\nfunction stream(req, res, options, _, server, clb) {\n  // And we begin!\n  server.emit('start', req, res, options.target);\n\n  if (options.forward) {\n    // If forward enable, so just pipe the request\n    var forwardReq = (options.forward.protocol === 'https:' ? https : http).request(common.setupOutgoing(options.ssl || {}, options, req, 'forward'));\n    (options.buffer || req).pipe(forwardReq);\n\n    if (!options.target) {\n      return res.end();\n    }\n  } // Request initalization\n\n\n  var proxyReq = (options.target.protocol === 'https:' ? https : http).request(common.setupOutgoing(options.ssl || {}, options, req)); // Enable developers to modify the proxyReq before headers are sent\n\n  proxyReq.on('socket', function (socket) {\n    if (server) {\n      server.emit('proxyReq', proxyReq, req, res, options);\n    }\n  }); // allow outgoing socket to timeout so that we could\n  // show an error page at the initial request\n\n  if (options.proxyTimeout) {\n    proxyReq.setTimeout(options.proxyTimeout, function () {\n      proxyReq.abort();\n    });\n  } // Ensure we abort proxy if request is aborted\n\n\n  req.on('aborted', function () {\n    proxyReq.abort();\n  }); // Handle errors on incoming request as well as it makes sense to\n\n  req.on('error', proxyError); // Error Handler\n\n  proxyReq.on('error', proxyError);\n\n  function proxyError(err) {\n    if (clb) {\n      clb(err, req, res, options.target);\n    } else {\n      server.emit('error', err, req, res, options.target);\n    }\n  }\n\n  (options.buffer || req).pipe(proxyReq);\n  proxyReq.on('response', function (proxyRes) {\n    if (server) {\n      server.emit('proxyRes', proxyRes, req, res);\n    }\n\n    for (var i = 0; i < web_o.length; i++) {\n      if (web_o[i](req, res, proxyRes, options)) {\n        break;\n      }\n    } // Allow us to listen when the proxy has completed\n\n\n    proxyRes.on('end', function () {\n      server.emit('end', req, res, proxyRes);\n    });\n    proxyRes.pipe(res);\n  }); //proxyReq.end();\n}] // <--\n.forEach(function (func) {\n  passes[func.name] = func;\n});","map":null,"metadata":{},"sourceType":"script"}